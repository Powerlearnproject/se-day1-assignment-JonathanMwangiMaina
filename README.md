[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15533674&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is an engineering branch related to the evolution of software production using well-defined scientific principles, techniques and procedures.
It is required for scalability (size/complexity), improved quality management, keeping the dynamic nature of software production in check and management of cost and ensuring effectiveness and reliability of the software product within the duration of a natural software development life cyle.

Identify and describe at least three key milestones in the evolution of software engineering.

1. The First Software Crisis (1960s): The increasing complexity of software projects led to delays, cost overruns, and unreliable products. This crisis prompted the development of software engineering principles.
2. Structured Programming (1960s-1970s): The introduction of structured programming techniques, such as top-down design and modularization, improved software readability and maintainability.
3. Object-Oriented Programming (1980s): Object-oriented programming paradigms provided a more intuitive way to model real-world problems, leading to more reusable and flexible software.

List and briefly explain the phases of the Software Development Life Cycle.

Stage 1 - Requirements Gathering: Identifying the specific needs and goals of the software. Planning for the quality assuarance requirements and identification of the risks associated with the project is also done at this stage.
Stage 2 - Design: Creating a blueprint of the software's architecture, components, and interactions. This is accomplished through "SRS" alias for Software Requirement Specification document which contains all the product requirements to be constructed and developed during the project life cycle.
Stage 3 - Development: Writing the code to implement the design. Developers have to follow the coding guidelines described by their management and programming tools like compilers, interpreters, debuggers, etc. are used to develop and implement the code.
Stage 4 - Testing: Verifying the software's functionality, performance, and reliability. Tests against the requirements or standards are conducted to make sure that the software product meets the needs and addresses the objectives prescribed earlier on in the previous stages. Unit testing, integration testing, system testing and acceptance (compatibility) testing are done during this stage. 
Stage 5 - Deployment: Installing the software in the production environment. Once the software is certified and no bugs or errors are stated, then it is deployed.
Stage 6 - Maintenance: Ongoing updates, bug fixes, and enhancements. Procedural care is taken for the developed product to address improving software performance and user experience.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

a) Waterfall: A linear approach with distinct phases. Suitable for projects with well-defined requirements and minimal changes.
b) Agile: An iterative approach with frequent releases and flexibility to adapt to changing requirements. Ideal for projects with uncertain requirements or rapid changes.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer: Writes code, implements features, and tests the software.
Quality Assurance Engineer: Tests the software for defects and ensures it meets quality standards.
Project Manager: Oversees the project, manages resources, and ensures it is completed on time and within budget.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

a) Integrated Development Environments provide tools for coding, debugging, and testing. Examples include Visual Studio, IntelliJ IDEA, and Eclipse.
b) Version Control Systems track changes to code over time, allowing for collaboration and easy rollback. Examples include Git, SVN, and Mercurial.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

a)Challenges Faced by Software Engineers
1. Complexity: Dealing with large and complex systems.
2. Changing Requirements: Adapting to evolving user needs.
3. Time Constraints: Meeting tight deadlines.
4. Technological Advancements: Keeping up with new technologies and tools.
   
b)Strategies to Overcome Challenges
1. Effective Communication: Collaborating with team members and stakeholders.
2. Continuous Learning: Staying updated on industry trends and best practices.
3. Prioritization: Focusing on the most critical tasks.
4. Testing and Debugging: Thoroughly testing and debugging code.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

a) Unit Testing - Used in testing individual components or functions.
b) Integration Testing - Tests the interaction between components.
c) System Testing - Used in testing the entire system as a whole.
d) Acceptance Testing - Tests the software against user requirements.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the art of crafting effective queries that help generative AI models understand and respond to diverse inputs. It involves understanding the model's capabilities and limitations and helps the generative AI model better comprehend and respond to a wide range of queries from the simple to the highly technical.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

a) Vague prompt: Generate a story about a city in 2030 which has advanced technology
b) Improved prompt: Write a story about a city in the future where everything is controlled by technology. Make characters who live there and have to deal with problems and difficult choices. Show how relying too much on technology can be bad and how people can still be strong.

The improved prompt can be considered more effective because the query conveys the instructions and intent clearly to the AI model; defines the task, clarifies the goal and states action to be taken.
